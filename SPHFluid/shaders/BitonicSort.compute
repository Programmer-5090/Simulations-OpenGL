#version 430

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct SpatialLookup {
    uint particleIndex;
    uint hash;
    uint cellKey;
};

layout(std430, binding = 0) restrict buffer SpatialLookupBuffer {
    SpatialLookup data[];
};

layout(std430, binding = 1) restrict buffer OffsetsBuffer {
    uint offsetData[];
};

uniform int numElements;
uniform int groupWidth;
uniform int groupHeight;
uniform int stepIndex;
uniform int currentKernel; // 0 = Sort, 1 = CalculateOffsets

void Sort() {
    uint i = gl_GlobalInvocationID.x;

    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    // Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= numElements) return;

    uint keyLeft = data[indexLeft].cellKey;
    uint keyRight = data[indexRight].cellKey;

    // Swap entries if value is descending
    if (keyLeft > keyRight) {
        SpatialLookup temp = data[indexLeft];
        data[indexLeft] = data[indexRight];
        data[indexRight] = temp;
    }
}

void CalculateOffsets() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= numElements) return;

    uint key = data[i].cellKey;
    uint hash = data[i].hash;
    uint keyPrev = i == 0 ? numElements : data[i - 1].cellKey;
    uint hashPrev = i == 0 ? numElements : data[i - 1].hash;

    if (key != keyPrev) {
        if (key < numElements) {
            offsetData[key] = i;
        }
    }
}

void main() {
    if (currentKernel == 0) {
        Sort();
    } else if (currentKernel == 1) {
        CalculateOffsets();
    }
}