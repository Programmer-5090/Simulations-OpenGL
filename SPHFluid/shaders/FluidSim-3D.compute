#version 430

const int ExternalForcesKernel = 0;
const int UpdateSpatialHashKernel = 1;
const int CalculateDensitiesKernel = 2;
const int CalculatePressureForcesKernel = 3;
const int CalculateViscosityKernel = 4;
const int UpdatePositionsKernel = 5;

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec3 position;
    vec3 velocity;
    vec3 predictedPosition;
    float density;
    float nearDensity;
    float pressure;
    float nearPressure;
};

struct SpatialLookup {
    uint particleIndex;
    uint hash;
    uint cellKey;
};

layout(std430, binding = 0) restrict buffer ParticleBuffer {
    Particle particles[];
};
layout(std430, binding = 1) restrict buffer SpatialLookupBuffer {
    SpatialLookup spatialLookup[];
};
layout(std430, binding = 2) restrict buffer StartIndicesBuffer {
    uint startIndices[];
};

layout(binding = 3, r32f) uniform image3D densityTexture;

// Uniforms
uniform int numParticles;
uniform float deltaTime;
uniform float gravity;
uniform float collisionDamping;
uniform float smoothingRadius;
uniform float targetDensity;
uniform float pressureMultiplier;
uniform float nearPressureMultiplier;
uniform float viscosityStrength;
uniform vec3 boundsSize;

uniform vec3 centre;
uniform mat4 localToWorld;
uniform mat4 worldToLocal;

uniform float poly6Factor;
uniform float spikyPow2Factor;
uniform float spikyPow3Factor;
uniform float spikyPow2DerivativeFactor;
uniform float spikyPow3DerivativeFactor;

uniform int currentKernel;
const ivec3 offsets3D[27] = ivec3[](
    ivec3(-1, -1, -1), ivec3(-1, -1, 0), ivec3(-1, -1, 1),
    ivec3(-1, 0, -1), ivec3(-1, 0, 0), ivec3(-1, 0, 1),
    ivec3(-1, 1, -1), ivec3(-1, 1, 0), ivec3(-1, 1, 1),
    ivec3(0, -1, -1), ivec3(0, -1, 0), ivec3(0, -1, 1),
    ivec3(0, 0, -1), ivec3(0, 0, 0), ivec3(0, 0, 1),
    ivec3(0, 1, -1), ivec3(0, 1, 0), ivec3(0, 1, 1),
    ivec3(1, -1, -1), ivec3(1, -1, 0), ivec3(1, -1, 1),
    ivec3(1, 0, -1), ivec3(1, 0, 0), ivec3(1, 0, 1),
    ivec3(1, 1, -1), ivec3(1, 1, 0), ivec3(1, 1, 1)
);

ivec3 GetCell(vec3 position) {
    return ivec3(floor(position / smoothingRadius));
}

uint HashCell(ivec3 cell) {
    uvec3 ucell = uvec3(cell);
    uint k1 = 15823;
    uint k2 = 9737333;
    uint k3 = 440817757;
    return ((ucell.x * k1) + (ucell.y * k2) + (ucell.z * k3));
}

float SmoothingKernelPoly6(float dst, float radius) {
    if (dst < radius) {
        float v = radius * radius - dst * dst;
        return v * v * v * poly6Factor;
    }
    return 0.0;
}

float SpikyKernelPow3(float dst, float radius) {
    if (dst < radius) {
        float v = radius - dst;
        return v * v * v * spikyPow3Factor;
    }
    return 0.0;
}

float SpikyKernelPow2(float dst, float radius) { 
    if (dst < radius) {
        float v = radius - dst;
        return v * v * spikyPow2Factor;
    }
    return 0.0;
}

float DerivativeSpikyPow2(float dst, float radius) {
    if (dst <= radius && dst > 0.0) {
        float v = radius - dst;
        return -v * spikyPow2DerivativeFactor;
    }
    return 0.0;
}

float DerivativeSpikyPow3(float dst, float radius) {
    if (dst <= radius && dst > 0.0) {
        float v = radius - dst;
        return -v * v * spikyPow3DerivativeFactor;
    }
    return 0.0;
}

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
	return nearDensity * nearPressureMultiplier;
}


void ProcessNeighbors(uint particleIndex, int kernelType, inout vec3 pressureForce, inout vec3 viscosityForce, inout float density, inout float nearDensity, bool includeSelf) {
    ivec3 originCell = GetCell(particles[particleIndex].predictedPosition);
    float sqrRadius = smoothingRadius * smoothingRadius;

    for (int i = 0; i < 27; i++) {
        uint hash = HashCell(originCell + offsets3D[i]);
        uint key = hash % uint(numParticles);
        if (key >= numParticles) continue;
        
        uint startIndex = startIndices[key];
        if (startIndex == numParticles) continue;

        for (uint j = startIndex; j < numParticles; j++) {
            if (spatialLookup[j].cellKey != key) break;
            if (spatialLookup[j].hash != hash) continue;
            
            uint neighborIndex = spatialLookup[j].particleIndex;
            if (!includeSelf && neighborIndex == particleIndex) continue;

            vec3 offset = particles[neighborIndex].predictedPosition - particles[particleIndex].predictedPosition;
            float sqrDst = dot(offset, offset);

            if (sqrDst <= sqrRadius) {
                float dst = sqrt(sqrDst);
                if (kernelType == CalculateDensitiesKernel) {
                    density += SpikyKernelPow2(dst, smoothingRadius);
                    nearDensity += SpikyKernelPow3(dst, smoothingRadius);
                } else if (kernelType == CalculatePressureForcesKernel) {
                    vec3 dirToNeighbor = (dst > 0) ? offset / dst : vec3(0, 1, 0);
                    
                    // Use pre-calculated pressure values with better stability checks
                    float neighborDensity = max(particles[neighborIndex].density, 0.1);
                    float neighborNearDensity = max(particles[neighborIndex].nearDensity, 0.1);
                    float currentDensity = max(particles[particleIndex].density, 0.1);
                    float currentNearDensity = max(particles[particleIndex].nearDensity, 0.1);
                    
                    float sharedPressure = (particles[particleIndex].pressure + particles[neighborIndex].pressure) * 0.5;
                    float sharedNearPressure = (particles[particleIndex].nearPressure + particles[neighborIndex].nearPressure) * 0.5;
                    
                    // Add stability by limiting force magnitude
                    vec3 pressureGradient = dirToNeighbor * DerivativeSpikyPow2(dst, smoothingRadius) * sharedPressure / neighborDensity;
                    vec3 nearPressureGradient = dirToNeighbor * DerivativeSpikyPow3(dst, smoothingRadius) * sharedNearPressure / neighborNearDensity;
                    
                    pressureForce += pressureGradient + nearPressureGradient;

                } else if (kernelType == CalculateViscosityKernel) {
                    viscosityForce += (particles[neighborIndex].velocity - particles[particleIndex].velocity) * SmoothingKernelPoly6(dst, smoothingRadius);
                }
            }
        }
    }
}

void HandleCollisions(inout Particle particle) {
    vec3 halfBounds = boundsSize * 0.5;
    
    // Boundary collisions with clamping to ensure particles stay within bounds
    if (abs(particle.position.x) > halfBounds.x) {
        particle.position.x = clamp(particle.position.x, -halfBounds.x, halfBounds.x);
        particle.velocity.x *= -collisionDamping;
    }
    if (abs(particle.position.y) > halfBounds.y) {
        particle.position.y = clamp(particle.position.y, -halfBounds.y, halfBounds.y);
        particle.velocity.y *= -collisionDamping;
    }
    if (abs(particle.position.z) > halfBounds.z) {
        particle.position.z = clamp(particle.position.z, -halfBounds.z, halfBounds.z);
        particle.velocity.z *= -collisionDamping;
    }
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= numParticles) return;

    if (currentKernel == ExternalForcesKernel) {
        particles[index].velocity += vec3(0, gravity, 0) * deltaTime;
        // Predict position
        const float predictionFactor = 1.0 / 120.0;
        particles[index].predictedPosition = particles[index].position + particles[index].velocity * predictionFactor;
    }
    else if (currentKernel == UpdateSpatialHashKernel) {
        startIndices[index] = numParticles; // Clear previous frame's start indices
        ivec3 cell = GetCell(particles[index].predictedPosition);
        uint hash = HashCell(cell);
        uint cellKey = hash % uint(numParticles);
        spatialLookup[index].particleIndex = index;
        spatialLookup[index].hash = hash;
        spatialLookup[index].cellKey = cellKey;
    }
    else if (currentKernel == CalculateDensitiesKernel) {
        particles[index].density = 0.0;
        particles[index].nearDensity = 0.0;
        vec3 dummyPressure = vec3(0.0);
        vec3 dummyViscosity = vec3(0.0);
        ProcessNeighbors(index, CalculateDensitiesKernel, dummyPressure, dummyViscosity, particles[index].density, particles[index].nearDensity, true);
        particles[index].pressure = (particles[index].density - targetDensity) * pressureMultiplier;
        particles[index].nearPressure = particles[index].nearDensity * nearPressureMultiplier;
    }
    else if (currentKernel == CalculatePressureForcesKernel) {
    vec3 pressureForce = vec3(0.0);
    vec3 dummyViscosity = vec3(0.0);
    float dummyDensity = 0.0;
    float dummyNearDensity = 0.0;
    ProcessNeighbors(index, CalculatePressureForcesKernel, pressureForce, dummyViscosity, dummyDensity, dummyNearDensity, false);

    // Calculate boundary repulsion forces
    vec3 boundaryForce = vec3(0.0);
    // float boundaryDistance = smoothingRadius * 0.8; // Distance at which boundary forces activate
    // vec3 pos = particles[index].predictedPosition;
    // vec3 halfBounds = boundsSize * 0.5;
    // float boundaryStiffness = 100000.0; // Adjust this value to control repulsion strength

    // // X boundaries - check if particle is OUTSIDE the safe zone
    // float distToRightBound = halfBounds.x - pos.x;
    // if (distToRightBound < boundaryDistance) {
    //     float penetration = boundaryDistance - distToRightBound;
    //     float normalizedPenetration = penetration / boundaryDistance;
    //     boundaryForce.x -= normalizedPenetration * normalizedPenetration * boundaryStiffness;
    // }
    
    // float distToLeftBound = pos.x - (-halfBounds.x);
    // if (distToLeftBound < boundaryDistance) {
    //     float penetration = boundaryDistance - distToLeftBound;
    //     float normalizedPenetration = penetration / boundaryDistance;
    //     boundaryForce.x += normalizedPenetration * normalizedPenetration * boundaryStiffness;
    // }

    // // Y boundaries
    // float distToTopBound = halfBounds.y - pos.y;
    // if (distToTopBound < boundaryDistance) {
    //     float penetration = boundaryDistance - distToTopBound;
    //     float normalizedPenetration = penetration / boundaryDistance;
    //     boundaryForce.y -= normalizedPenetration * normalizedPenetration * boundaryStiffness;
    // }
    
    // float distToBottomBound = pos.y - (-halfBounds.y);
    // if (distToBottomBound < boundaryDistance) {
    //     float penetration = boundaryDistance - distToBottomBound;
    //     float normalizedPenetration = penetration / boundaryDistance;
    //     boundaryForce.y += normalizedPenetration * normalizedPenetration * boundaryStiffness;
    // }

    // // Z boundaries
    // float distToFrontBound = halfBounds.z - pos.z;
    // if (distToFrontBound < boundaryDistance) {
    //     float penetration = boundaryDistance - distToFrontBound;
    //     float normalizedPenetration = penetration / boundaryDistance;
    //     boundaryForce.z -= normalizedPenetration * normalizedPenetration * boundaryStiffness;
    // }
    
    // float distToBackBound = pos.z - (-halfBounds.z);
    // if (distToBackBound < boundaryDistance) {
    //     float penetration = boundaryDistance - distToBackBound;
    //     float normalizedPenetration = penetration / boundaryDistance;
    //     boundaryForce.z += normalizedPenetration * normalizedPenetration * boundaryStiffness;
    // }

    // Apply pressure forces
    float currentDensity = max(particles[index].density, 0.01);
    vec3 acceleration = (pressureForce + boundaryForce) / currentDensity;
    particles[index].velocity += acceleration * deltaTime;
}
    else if (currentKernel == CalculateViscosityKernel) {
        vec3 viscosityForce = vec3(0.0);
        vec3 dummyPressure = vec3(0.0);
        float dummyDensity = 0.0;
        float dummyNearDensity = 0.0;
        ProcessNeighbors(index, CalculateViscosityKernel, dummyPressure, viscosityForce, dummyDensity, dummyNearDensity, false);
        particles[index].velocity += viscosityForce * viscosityStrength * deltaTime;
    }
    else if (currentKernel == UpdatePositionsKernel) {
        // Add velocity damping to help particles settle
        particles[index].velocity *= 0.995;

        // Update positions
        vec3 newPosition = particles[index].position + particles[index].velocity * deltaTime;
        if (isnan(newPosition.x) || isnan(newPosition.y) || isnan(newPosition.z) || 
            isinf(newPosition.x) || isinf(newPosition.y) || isinf(newPosition.z)) {
            newPosition = vec3(0.0, 0.0, 0.0);
            particles[index].velocity = vec3(0.0, 0.0, 0.0);
        }
        particles[index].position = newPosition;
        HandleCollisions(particles[index]);
    }
}